<!doctype html>
<html lang="uk">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Морський бій</title>
<style>
  :root{ --bg:#0475E6; --panel:#0353B3; --accent:#0A9EFF; --text:#DBEBFB; --sunk:#7A1F1F; --sunk-border:#FF8080; }
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{ background:var(--bg); color:var(--text); display:flex; gap:8px; padding:10px; box-sizing:border-box; user-select:none; align-items:flex-start; }
  .player { width:calc(50% - 12px); box-sizing:border-box; padding:8px; display:flex; flex-direction:column; align-items:center; gap:10px; }
  .panel { background:var(--panel); border:2px solid var(--accent); padding:8px; border-radius:8px; width:100%; box-sizing:border-box; }
  .info { font-weight:700; margin-bottom:8px; text-align:center; }
  .status { min-height:22px; margin-top:8px; text-align:center; font-weight:600; color:var(--text); }
  .grid { display:grid; grid-template-columns: repeat(14, 1fr); gap:3px; width:100%; aspect-ratio:1; max-width:680px; margin:0 auto; user-select:none; touch-action: manipulation; position:relative; }
  .cell { background: #0669C9; border-radius:4px; aspect-ratio:1; display:flex; align-items:center; justify-content:center; font-weight:700; color: transparent; font-size:14px; line-height:1; border:1px solid rgba(10,158,255,0.18); }
  .cell.water { background:#0669C9; color:transparent; }
  .cell.ship { background:#0A9EFF; color:transparent; }
  .cell.hidden { background:#0669C9; color:transparent; }
  .cell.hit { background:#D14949; color:var(--text); }
  .cell.miss { background:#DBEBFB; color:#0475E6; }
  .cell.sunk { background: var(--sunk); border:2px solid var(--sunk-border); color:var(--text); }
  .controls { display:flex; gap:8px; justify-content:center; margin-top:8px; flex-wrap:wrap; }
  button{background:var(--accent); color:var(--text); border:none; padding:8px 12px; border-radius:6px; font-weight:700; cursor:pointer;}
  button:disabled{opacity:.5; cursor:default; background:#0353B3;}
  /* Ship stats */
  .ship-stats { background:var(--panel); border:2px solid var(--accent); padding:8px; border-radius:8px; margin-top:8px; width:100%; box-sizing:border-box; }
  .stats-title{ font-weight:800; margin-bottom:6px; }
  .ships-list{ display:flex; flex-direction:column; gap:6px; }
  .ship-item{ display:flex; align-items:center; gap:8px; padding:4px 0; border-bottom:1px solid rgba(10,158,255,0.08); }
  .ship-item:last-child{ border-bottom:none; }
  .ship-count{ font-weight:800; min-width:24px; }
  .sunk-mark{ flex-grow:1; height:8px; background:transparent; border-radius:4px; }
  .ship-item.sunk .sunk-mark{ background:var(--sunk-border); }
  /* Radar */
  .radar { width:100%; max-width:320px; padding:8px; box-sizing:border-box; background:linear-gradient(180deg,#024b86,#013f74); border-radius:12px; border:2px solid #0A9EFF; display:flex; flex-direction:column; align-items:center; gap:8px; }
  .radar-title{ font-weight:800; color:var(--text); font-size:14px; text-align:center; }
  .radar-container { position:relative; width:210px; height:210px; background:#0353B3; border-radius:50%; overflow:hidden; display:block; clip-path: circle(50% at 50% 50%); }
  .r-cell{ position:absolute; box-sizing:border-box; border:1px solid rgba(10,158,255,0.08); background:#024b86; font-size:11px; line-height:1; display:flex; align-items:center; justify-content:center; color:transparent; opacity:0; transition: opacity 200ms linear; }
  .r-cell.sunk{ background:#D14949; opacity:0.5; }
  #radar-scan{ position:absolute; inset:0; border-radius:50%; background: radial-gradient(circle, rgba(255,255,255,0.14) 0%, rgba(255,255,255,0.06) 40%, rgba(255,255,255,0.0) 70%), conic-gradient(rgba(255,255,255,0.45) 0deg, rgba(255,255,255,0.05) 40deg, rgba(255,255,255,0) 60deg); animation: rotate 4s linear infinite; mix-blend-mode:screen; pointer-events:none; }
  @keyframes rotate { from{transform:rotate(0deg)} to{transform:rotate(360deg)} }
  .placement-controls{ display:flex; gap:6px; justify-content:center; margin-top:6px; }
  .rotate-btn{ padding:6px 8px; font-weight:700; border-radius:6px; }
  @media (pointer: coarse) { body { flex-direction:column; gap:12px; align-items:stretch; } .player { width:100%; } .radar { width:100%; max-width:100%; } .grid { gap:4px; } button{padding:12px 20px; font-size:18px;} .status{font-size:16px;} .radar-container { width:160px; height:160px; } }
</style>
</head>
<body>

<div class="player" id="player1">
  <div class="panel">
    <div class="info" id="info1">Гравець №1 — Розстановка</div>
    <div class="grid" id="grid1" tabindex="0" aria-label="Поле гравця 1"></div>
    <div class="controls">
      <button id="auto1">Авто</button>
      <button id="ready1" disabled>Готово</button>
      <button id="reset1">Скинути</button>
    </div>
    <div class="placement-controls">
      <button id="rotate1" class="rotate-btn">Орієнтація: H</button>
      <div class="ship-stats" id="stats1">
        <div class="stats-title">Статистика кораблів</div>
        <div class="ships-list"></div>
      </div>
    </div>
    <div class="status" id="status1"></div>
  </div>
  <div class="radar" id="radar1"><div class="radar-title">Радар (бачить лише потоплені кораблі суперника)</div><div class="radar-container" id="radar1-container"></div></div>
</div>

<div class="player" id="player2">
  <div class="panel">
    <div class="info" id="info2">Гравець №2 — Чекає</div>
    <div class="grid" id="grid2" tabindex="0" aria-label="Поле гравця 2"></div>
    <div class="controls">
      <button id="auto2">Авто</button>
      <button id="ready2" disabled>Готово</button>
      <button id="reset2">Скинути</button>
    </div>
    <div class="placement-controls">
      <button id="rotate2" class="rotate-btn">Орієнтація: H</button>
      <div class="ship-stats" id="stats2">
        <div class="stats-title">Статистика кораблів</div>
        <div class="ships-list"></div>
      </div>
    </div>
    <div class="status" id="status2"></div>
  </div>
  <div class="radar" id="radar2"><div class="radar-title">Радар (бачить лише потоплені кораблі суперника)</div><div class="radar-container" id="radar2-container"></div></div>
</div>

<script>
/* ===== Constants & Config ===== */
const ROWS = 14, COLS = 14;
const shipsConfig = [ {size:5,count:1},{size:4,count:2},{size:3,count:3},{size:2,count:4},{size:1,count:5} ];

/* ===== Classes (structural improvements) ===== */
class Ship {
  constructor(size){ this.size = size; this.cells = []; this.hits = new Set(); this.sunk = false; }
  addCell(r,c){ this.cells.push({r,c}); }
  isSunk(){ return this.hits.size === this.size; }
}

class GameField {
  constructor(rows,cols){ this.rows=rows; this.cols=cols; this.field = Array.from({length:rows},()=>Array(cols).fill(0)); this.ships=[]; this.shipMap = new Map(); }
  isInBounds(r,c){ return r>=0 && r<this.rows && c>=0 && c<this.cols; }
  hasAdjacentShip(r,c){ for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ const rr=r+dr, cc=c+dc; if(this.isInBounds(rr,cc) && this.field[rr][cc]===1) return true; } return false; }
  canPlaceShip(size,r,c,orient){ if(orient==='H'){ if(c+size>this.cols) return false; for(let i=0;i<size;i++){ const rr=r, cc=c+i; if(this.field[rr][cc]===1) return false; if(this.hasAdjacentShip(rr,cc)) return false; } } else { if(r+size>this.rows) return false; for(let i=0;i<size;i++){ const rr=r+i, cc=c; if(this.field[rr][cc]===1) return false; if(this.hasAdjacentShip(rr,cc)) return false; } } return true; }
  placeShip(ship,r,c,orient){ if(!this.canPlaceShip(ship.size,r,c,orient)) return false; ship.cells=[]; const idx=this.ships.length; for(let i=0;i<ship.size;i++){ const rr=orient==='H'?r:r+i; const cc=orient==='H'?c+i:c; this.field[rr][cc]=1; ship.addCell(rr,cc); this.shipMap.set(`${rr},${cc}`,idx); } this.ships.push(ship); return true; }
  removeShipAt(r,c){ const k=`${r},${c}`; if(!this.shipMap.has(k)) return false; const idx=this.shipMap.get(k); const ship=this.ships[idx]; if(!ship) return false; for(const cell of ship.cells){ this.field[cell.r][cell.c]=0; this.shipMap.delete(`${cell.r},${cell.c}`); } this.ships[idx]=null; return true; }
  checkAndMarkSunk(ship){ for(const cell of ship.cells){ if(this.field[cell.r][cell.c] !== 3) return false; } ship.sunk=true; for(const cell of ship.cells){ for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ const rr=cell.r+dr, cc=cell.c+dc; if(this.isInBounds(rr,cc) && this.field[rr][cc]===0){ this.field[rr][cc]=2; } } } return true; }
}

class GameEventManager {
  constructor(){ this.listeners = new Map(); }
  on(event,cb){ if(!this.listeners.has(event)) this.listeners.set(event,new Set()); this.listeners.get(event).add(cb); return ()=>this.off(event,cb); }
  off(event,cb){ if(this.listeners.has(event)) this.listeners.get(event).delete(cb); }
  emit(event,data){ if(this.listeners.has(event)) for(const cb of this.listeners.get(event)) cb(data); }
}

class RadarRenderer {
  constructor(container, rows, cols){ this.container = container; this.rows=rows; this.cols=cols; this.cells=[]; this.scan=null; this.init(); }
  init(){ if(!this.container) return; this.container.innerHTML=''; this.createCells(); this.scan = document.createElement('div'); this.scan.id='radar-scan'; this.container.appendChild(this.scan); }
  createCells(){ const contW = this.container.clientWidth || 210; const cellSize = Math.floor(contW / this.cols); const totalW = cellSize * this.cols; const offset = Math.floor((contW - totalW)/2); for(let r=0;r<this.rows;r++){ for(let c=0;c<this.cols;c++){ const el = document.createElement('div'); el.className='r-cell'; el.style.top = (r*cellSize + offset) + 'px'; el.style.left = (c*cellSize + offset) + 'px'; el.style.width = cellSize + 'px'; el.style.height = cellSize + 'px'; el.dataset.r=r; el.dataset.c=c; this.container.appendChild(el); this.cells.push({el,r,c}); } } }
  update(sunkPositions){ for(const item of this.cells){ const k=`${item.r},${item.c}`; if(sunkPositions.has(k)) item.el.classList.add('sunk'); else item.el.classList.remove('sunk'); } }
}

/* ===== Game State (using classes) ===== */
const fieldObj1 = new GameField(ROWS,COLS);
const fieldObj2 = new GameField(ROWS,COLS);
let shotsByPlayer = {1: new Set(), 2: new Set()};
let playerReady = {1:false,2:false};
let phase = 'placement1';
let currentPlayer = 1;

/* ===== DOM refs ===== */
const grid1 = document.getElementById('grid1');
const grid2 = document.getElementById('grid2');
const info1 = document.getElementById('info1'), info2 = document.getElementById('info2');
const status1 = document.getElementById('status1'), status2 = document.getElementById('status2');
const ready1 = document.getElementById('ready1'), ready2 = document.getElementById('ready2');
const reset1 = document.getElementById('reset1'), reset2 = document.getElementById('reset2');
const auto1 = document.getElementById('auto1'), auto2 = document.getElementById('auto2');
const rotate1 = document.getElementById('rotate1'), rotate2 = document.getElementById('rotate2');
const stats1El = document.querySelector('#stats1 .ships-list');
const stats2El = document.querySelector('#stats2 .ships-list');
const radar1Container = document.getElementById('radar1-container');
const radar2Container = document.getElementById('radar2-container');

/* ===== Helpers ===== */
const key = (r,c)=>`${r},${c}`;
function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }
function countPlacedBySize(fieldObj){ const counts = new Map(); for(const s of fieldObj.ships){ if(!s) continue; counts.set(s.size,(counts.get(s.size)||0)+1); } return counts; }
function remainingToPlaceForField(fieldObj){ const placed = countPlacedBySize(fieldObj); const remaining = []; for(const sc of shipsConfig){ const placedCnt = placed.get(sc.size)||0; const left = Math.max(0, sc.count-placedCnt); for(let i=0;i<left;i++) remaining.push(sc.size); } remaining.sort((a,b)=>b-a); return remaining; }

/* ===== Rendering helpers ===== */
function makeEmptyGridDOM(gridEl){ gridEl.innerHTML=''; const frag=document.createDocumentFragment(); for(let r=0;r<ROWS;r++){ for(let c=0;c<COLS;c++){ const div = document.createElement('div'); div.className='cell water'; div.dataset.r=r; div.dataset.c=c; frag.appendChild(div); } } gridEl.appendChild(frag); }
function updateCell(gridEl, fieldObj, r, c, showShips){ const idx = r*COLS + c; const cell = gridEl.children[idx]; const val = fieldObj.field[r][c]; cell.className='cell'; delete cell.dataset.sunk; if(val===0){ cell.classList.add('water'); cell.textContent=''; } else if(val===1){ if(showShips){ cell.classList.add('ship'); cell.textContent=''; } else { cell.classList.add('hidden'); cell.textContent=''; } } else if(val===2){ cell.classList.add('miss'); cell.textContent='o'; } else if(val===3){ cell.classList.add('hit'); cell.textContent='X'; } else { cell.classList.add('water'); cell.textContent=''; } }

function renderFull(){ const showShips1 = (phase==='placement1') || (phase==='showShips'); const showShips2 = (phase==='placement2') || (phase==='showShips'); for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ updateCell(grid1, fieldObj1, r, c, showShips1); updateCell(grid2, fieldObj2, r, c, showShips2); }
  // sunk styling
  for(const s of fieldObj1.ships){ if(!s) continue; if(s.sunk){ for(const cell of s.cells){ const idx = cell.r*COLS + cell.c; grid1.children[idx].dataset.sunk='1'; grid1.children[idx].classList.add('sunk'); grid1.children[idx].textContent='X'; } } }
  for(const s of fieldObj2.ships){ if(!s) continue; if(s.sunk){ for(const cell of s.cells){ const idx = cell.r*COLS + cell.c; grid2.children[idx].dataset.sunk='1'; grid2.children[idx].classList.add('sunk'); grid2.children[idx].textContent='X'; } } }
  // phase UI
  if(phase==='placement1'){ const rem = remainingToPlaceForField(fieldObj1); info1.textContent = `Гравець №1 — Розстановка (${rem.length} кораблів)`; info2.textContent='Гравець №2 — Чекає'; ready1.disabled = rem.length>0; ready2.disabled=true; }
  else if(phase==='placement2'){ const rem = remainingToPlaceForField(fieldObj2); info1.textContent='Гравець №1 — Чекає'; info2.textContent=`Гравець №2 — Розстановка (${rem.length} кораблів)`; ready1.disabled=true; ready2.disabled = rem.length>0; }
  else if(phase==='showShips'){ info1.textContent='Показ кораблів...'; info2.textContent='Показ кораблів...'; ready1.disabled=true; ready2.disabled=true; }
  else if(phase==='battle'){ info1.textContent = currentPlayer===1 ? 'Гравець №1 — Твій хід' : 'Гравець №1 — Чекає'; info2.textContent = currentPlayer===2 ? 'Гравець №2 — Твій хід' : 'Гравець №2 — Чекає'; ready1.disabled=true; ready2.disabled=true; }
  else if(phase==='finished'){ info1.textContent='Гра завершена'; info2.textContent='Гра завершена'; }
  renderShipStats(); renderRadars(); }

/* ===== Initial grids ===== */
makeEmptyGridDOM(grid1); makeEmptyGridDOM(grid2);

/* ===== Optimized Web Worker (auto placement) ===== */
const workerCode = `
self.onmessage = function(e){ const {cmd,data} = e.data; if(cmd==='autoPlace'){ const ROWS = data.ROWS, COLS = data.COLS; const shipsConfig = data.shipsConfig; function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; } function hasAdjacent(field,r,c){ for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ const rr=r+dr, cc=c+dc; if(inBounds(rr,cc) && field[rr][cc]===1) return true; } return false; } function canPlace(field,r,c,size,orient){ if(orient==='H'){ if(c+size>COLS) return false; for(let i=0;i<size;i++){ const rr=r, cc=c+i; if(field[rr][cc]!==0) return false; if(hasAdjacent(field,rr,cc)) return false; } } else { if(r+size>ROWS) return false; for(let i=0;i<size;i++){ const rr=r+i, cc=c; if(field[rr][cc]!==0) return false; if(hasAdjacent(field,rr,cc)) return false; } } return true; }
 const field = Array.from({length:ROWS}, ()=> Array(COLS).fill(0)); const shipsResult = []; const sizes=[]; shipsConfig.forEach(sc=>{ for(let i=0;i<sc.count;i++) sizes.push(sc.size); }); sizes.sort((a,b)=>b-a); for(const size of sizes){ const attempts=1000; let placed=false; for(let attempt=0;attempt<attempts && !placed;attempt++){ const orient = Math.random()<0.5?'H':'V'; const r = Math.floor(Math.random()*ROWS); const c = Math.floor(Math.random()*COLS); if(canPlace(field,r,c,size,orient)){ const cells=[]; for(let i=0;i<size;i++){ const rr = orient==='H'? r : r+i; const cc = orient==='H'? c+i : c; field[rr][cc]=1; cells.push({r:rr,c:cc}); } shipsResult.push({cells,size,orient}); placed=true; } } if(!placed){ self.postMessage({cmd:'autoResult', ok:false}); return; } }
 self.postMessage({cmd:'autoResult', ok:true, ships:shipsResult}); } };`;
const workerBlob = new Blob([workerCode], {type:'application/javascript'});
const worker = new Worker(URL.createObjectURL(workerBlob));
function workerAutoPlace(){ return new Promise((resolve)=>{ const onmsg = (e)=>{ if(e.data && e.data.cmd==='autoResult'){ worker.removeEventListener('message', onmsg); resolve(e.data); } }; worker.addEventListener('message', onmsg); worker.postMessage({cmd:'autoPlace', data:{ROWS,COLS,shipsConfig}}); }); }

/* ===== Auto placement & interaction ===== */
async function autoPlaceFor(player){ const res = await workerAutoPlace(); if(!res.ok){ statusFor(player,'Авто-розстановка не вдалась.'); return; } const targetField = player===1? fieldObj1 : fieldObj2; // clear
 for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) targetField.field[r][c]=0; targetField.ships.length=0; targetField.shipMap.clear(); // apply
 for(const s of res.ships){ const ship = new Ship(s.size); for(const cell of s.cells){ ship.addCell(cell.r,cell.c); targetField.field[cell.r][cell.c]=1; targetField.shipMap.set(key(cell.r,cell.c), targetField.ships.length); } targetField.ships.push(ship); }
 statusFor(player,'Авто-розстановка завершена. Клікніть по кораблю щоб видалити його і розмістити заново.'); if(player===1) ready1.disabled=false; else ready2.disabled=false; renderFull(); }

/* Allow clicking a ship cell after auto to remove that ship and let player place it manually */
let placeOrient = {1:'H',2:'H'};
rotate1.addEventListener('click', ()=>{ placeOrient[1] = placeOrient[1]==='H'?'V':'H'; rotate1.textContent = `Орієнтація: ${placeOrient[1]}`; });
rotate2.addEventListener('click', ()=>{ placeOrient[2] = placeOrient[2]==='H'?'V':'H'; rotate2.textContent = `Орієнтація: ${placeOrient[2]}`; });

function onOwnerGridClick(e, owner){ const rect = e.currentTarget.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top; const c = Math.floor(x / (rect.width / COLS)); const r = Math.floor(y / (rect.height / ROWS)); if(!inBounds(r,c)) return; const fieldObj = owner===1? fieldObj1 : fieldObj2; // if click on ship cell and phase is placement for that player or after auto allow removal
 if(fieldObj.field[r][c] === 1 && (phase===`placement${owner}` || phase.startsWith('placement'))){ // remove ship
   const removed = fieldObj.removeShipAt(r,c);
   if(removed){ statusFor(owner,'Корабель видалено. Розмістіть його вручну (клік на клітинку) або натисніть Авто.'); makeEmptyGridDOM(owner===1?grid1:grid2); renderFull(); }
   return;
 }
 // manual placement: if it's the player's placement phase AND there are remaining ships
 if((phase===`placement${owner}`) || (phase.startsWith('placement'))){ const rem = remainingToPlaceForField(fieldObj); if(rem.length===0) return; const size = rem[0]; const orient = placeOrient[owner]; if(fieldObj.canPlaceShip(size,r,c,orient)){ const ship = new Ship(size); fieldObj.placeShip(ship,r,c,orient); statusFor(owner, `Розміщено корабель розміру ${size}`); makeEmptyGridDOM(owner===1?grid1:grid2); renderFull(); } else { statusFor(owner,'Неможливо розмістити корабель тут.'); } }
}

grid1.addEventListener('click',(e)=> onOwnerGridClick(e,1));
grid2.addEventListener('click',(e)=> onOwnerGridClick(e,2));

auto1.addEventListener('click', ()=> autoPlaceFor(1)); auto2.addEventListener('click', ()=> autoPlaceFor(2));

/* ===== Ready / Reset ===== */
ready1.addEventListener('click', ()=>{ playerReady[1]=true; ready1.disabled=true; if(playerReady[2]) startShowAndBattle(); else { phase='placement2'; renderFull(); } });
ready2.addEventListener('click', ()=>{ playerReady[2]=true; ready2.disabled=true; if(playerReady[1]) startShowAndBattle(); else { phase='placement1'; renderFull(); } });
function startShowAndBattle(){ phase='showShips'; renderFull(); setTimeout(()=>{ phase='battle'; currentPlayer=1; renderFull(); }, 2000); }
reset1.addEventListener('click', ()=>{ for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) fieldObj1.field[r][c]=0; fieldObj1.ships=[]; fieldObj1.shipMap.clear(); shotsByPlayer[1].clear(); playerReady[1]=false; phase='placement1'; ready1.disabled=true; ready2.disabled=true; makeEmptyGridDOM(grid1); makeEmptyGridDOM(grid2); renderFull(); });
reset2.addEventListener('click', ()=>{ for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) fieldObj2.field[r][c]=0; fieldObj2.ships=[]; fieldObj2.shipMap.clear(); shotsByPlayer[2].clear(); playerReady[2]=false; phase='placement1'; ready1.disabled=true; ready2.disabled=true; makeEmptyGridDOM(grid1); makeEmptyGridDOM(grid2); renderFull(); });

/* ===== Shooting (battle) ===== */
function handleShotAt(ownerGrid, clickX, clickY){ if(phase !== 'battle') return; const rect = ownerGrid.getBoundingClientRect(); const x = clickX - rect.left; const y = clickY - rect.top; if(x<0||y<0||x>rect.width||y>rect.height) return; const c = Math.floor(x / (rect.width / COLS)); const r = Math.floor(y / (rect.height / ROWS)); if(!inBounds(r,c)) return; const shooter = (ownerGrid===grid1) ? 2 : 1; if(shooter !== currentPlayer) return; const opponentField = shooter===1? fieldObj2 : fieldObj1; const opponentObj = shooter===1? fieldObj2 : fieldObj1; const shotsSet = shotsByPlayer[shooter]; const k = key(r,c); if(shotsSet.has(k)){ statusFor(shooter,'Цю клітинку вже обстріляно!'); return; } shotsSet.add(k); if(opponentField.field[r][c] === 1){ opponentField.field[r][c] = 3; const shipIdx = opponentField.shipMap.get(k); if(typeof shipIdx==='number'){ const ship = opponentField.ships[shipIdx]; if(ship){ ship.hits.add(k); const sunk = opponentField.checkAndMarkSunk(ship); if(sunk){ statusFor(shooter,'Корабель потоплено!'); renderFull(); } else { statusFor(shooter,'Влучання! Продовжуйте ходити.'); renderFull(); } } } const relevant = opponentField.ships.filter(Boolean); const allSunk = relevant.length>0 && relevant.every(s=>s.sunk); if(allSunk){ phase='finished'; renderFull(); setTimeout(()=>alert(`Гравець №${shooter} переміг!`),100); statusFor(shooter,'Ви перемогли!'); return; } // shooter continues
 } else { if(opponentField.field[r][c] === 0) opponentField.field[r][c] = 2; statusFor(shooter,'Промах. Хід переходить супернику.'); currentPlayer = currentPlayer===1?2:1; renderFull(); }
}

grid1.addEventListener('click',(e)=>{ if(phase==='battle') handleShotAt(grid1,e.clientX,e.clientY); });
grid2.addEventListener('click',(e)=>{ if(phase==='battle') handleShotAt(grid2,e.clientX,e.clientY); });

/* ===== Radars using RadarRenderer ===== */
let radar1, radar2;
function buildRadars(){ radar1 = new RadarRenderer(radar1Container, ROWS, COLS); radar2 = new RadarRenderer(radar2Container, ROWS, COLS); }
buildRadars(); window.addEventListener('resize', ()=>{ buildRadars(); renderRadars(); });
function renderRadars(){ const sunk2 = new Set(); for(const s of fieldObj2.ships){ if(!s) continue; if(s.sunk) for(const cell of s.cells) sunk2.add(key(cell.r,cell.c)); } radar1.update(sunk2); const sunk1 = new Set(); for(const s of fieldObj1.ships){ if(!s) continue; if(s.sunk) for(const cell of s.cells) sunk1.add(key(cell.r,cell.c)); } radar2.update(sunk1); }

/* ===== Ship stats UI ===== */
function renderShipStats(){ function renderFor(fieldObj, container){ container.innerHTML=''; for(const sc of shipsConfig){ const total = sc.count; const placed = (fieldObj.ships.filter(s=>s && s.size===sc.size)).length; const sunk = (fieldObj.ships.filter(s=>s && s.size===sc.size && s.sunk)).length; const item = document.createElement('div'); item.className='ship-item'+(sunk===total?' sunk':''); item.dataset.size = sc.size; item.innerHTML = `<span class="ship-count">${total - placed}</span><span class="ship-name">${sc.size}-палуб.</span><span class="sunk-mark"></span>`; container.appendChild(item); } }
 renderFor(fieldObj1, stats1El); renderFor(fieldObj2, stats2El); }

/* ===== Status helpers ===== */
function statusFor(player,text){ if(player===1) status1.textContent=text; else status2.textContent=text; }

/* ===== Initial render ===== */
renderFull();

</script>
</body>
</html>
